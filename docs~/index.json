{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Documentation to code of Save System package",
    "keywords": "Documentation to code of Save System package Base classes of the save system: DataManager - saving and loading your objects UnityWriter - writing your data UnityReader - reading your data UnityAsyncWriter - as UnityWriter, but it writing data async UnityAsyncReader - as UnityReader, but it reading data async Dependencies: UniTask - adapts async\\await to Unity"
  },
  "api/SaveSystem.AsyncMode.html": {
    "href": "api/SaveSystem.AsyncMode.html",
    "title": "Enum AsyncMode",
    "keywords": "Enum AsyncMode Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public enum AsyncMode"
  },
  "api/SaveSystem.DataManager.html": {
    "href": "api/SaveSystem.DataManager.html",
    "title": "Class DataManager",
    "keywords": "Class DataManager Main class for handling objects Inheritance object DataManager Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public static class DataManager Methods LoadObject<T>(string, T) Load one object public static bool LoadObject<T>(string fileName, T obj) where T : IPersistentObject Parameters fileName string the file whereof the object data will be load obj T the object which will be load Returns bool Returns true if there is saved data, otherwise false Type Parameters T LoadObjectAsync<T>(string, T, AsyncMode, CancellationTokenSource, Action) Load one object async public static UniTask<bool> LoadObjectAsync<T>(string fileName, T obj, AsyncMode asyncMode, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObject Parameters fileName string the file whereof the object data will be load obj T the object which will be load asyncMode AsyncMode source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Type Parameters T Exceptions OperationCanceledException throws when loading is canceled LoadObjectAsyncAdvanced<T>(string, T, CancellationTokenSource, Action) Load one object async public static UniTask<bool> LoadObjectAsyncAdvanced<T>(string fileName, T obj, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObjectAsync Parameters fileName string the file whereof the object data will be load obj T the object which will be load source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Type Parameters T Exceptions OperationCanceledException throws when loading is canceled LoadObjects<T>(string, T[]) Load many objects public static bool LoadObjects<T>(string fileName, T[] objects) where T : IPersistentObject Parameters fileName string the file whereof the object data will be load objects T[] the objects which will be load Returns bool Returns true if there is saved data, otherwise false Type Parameters T LoadObjectsAsync<T>(string, T[], AsyncMode, IProgress<float>, CancellationTokenSource, Action) Load many objects async public static UniTask<bool> LoadObjectsAsync<T>(string fileName, T[] objects, AsyncMode asyncMode, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObject Parameters fileName string the file whereof the object data will be load objects T[] the objects which will be load asyncMode AsyncMode progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Type Parameters T Exceptions OperationCanceledException throws when loading is canceled LoadObjectsAsyncAdvanced<T>(string, T[], IProgress<float>, CancellationTokenSource, Action) Load many objects async public static UniTask<bool> LoadObjectsAsyncAdvanced<T>(string fileName, T[] objects, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObjectAsync Parameters fileName string the file whereof the object data will be load objects T[] the objects which will be load progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Type Parameters T Exceptions OperationCanceledException throws when loading is canceled SaveObject<T>(string, T) Save one object public static void SaveObject<T>(string fileName, T obj) where T : IPersistentObject Parameters fileName string the file where the object data will be saved obj T the object which will be saved Type Parameters T SaveObjectAsync<T>(string, T, AsyncMode, CancellationTokenSource, Action) Save one object async public static UniTask SaveObjectAsync<T>(string fileName, T obj, AsyncMode asyncMode, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObject Parameters fileName string the file where the object data will be saved obj T the object which will be saved asyncMode AsyncMode source CancellationTokenSource onComplete Action Returns UniTask Type Parameters T Exceptions OperationCanceledException throws when saving is canceled SaveObjectAsyncAdvanced<T>(string, T, CancellationTokenSource, Action) Save one object async public static UniTask SaveObjectAsyncAdvanced<T>(string fileName, T obj, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObjectAsync Parameters fileName string the file where the object data will be saved obj T the object which will be saved source CancellationTokenSource onComplete Action Returns UniTask Type Parameters T Exceptions OperationCanceledException throws when saving is canceled SaveObjects<T>(string, T[]) Save many objects public static void SaveObjects<T>(string fileName, T[] objects) where T : IPersistentObject Parameters fileName string the file where the object data will be saved objects T[] the objects which will be saved Type Parameters T SaveObjectsAsync<T>(string, T[], AsyncMode, IProgress<float>, CancellationTokenSource, Action) Save many objects async public static UniTask SaveObjectsAsync<T>(string fileName, T[] objects, AsyncMode asyncMode, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObject Parameters fileName string the file where the object data will be saved objects T[] the objects which will be saved asyncMode AsyncMode progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask Type Parameters T Exceptions OperationCanceledException throws when saving is canceled SaveObjectsAsyncAdvanced<T>(string, T[], IProgress<float>, CancellationTokenSource, Action) Save many objects async public static UniTask SaveObjectsAsyncAdvanced<T>(string fileName, T[] objects, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) where T : IPersistentObjectAsync Parameters fileName string the file where the object data will be saved objects T[] the objects which will be saved progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask Type Parameters T Exceptions OperationCanceledException throws when saving is canceled"
  },
  "api/SaveSystem.html": {
    "href": "api/SaveSystem.html",
    "title": "Namespace SaveSystem",
    "keywords": "Namespace SaveSystem Classes DataManager Main class for handling objects UnityAsyncReader Adapter to class BinaryReader for simplify reading data async UnityAsyncWriter Adapter to class BinaryWriter for simplify writing data async UnityReader Adapter to class BinaryReader for simplify reading data UnityWriter Adapter to class BinaryWriter for simplify writing data Structs MeshData Contains the data of a mesh. Mesh can be casted to MeshData and vice-versa Interfaces IPersistentObject IPersistentObjectAsync Enums AsyncMode"
  },
  "api/SaveSystem.IPersistentObject.html": {
    "href": "api/SaveSystem.IPersistentObject.html",
    "title": "Interface IPersistentObject",
    "keywords": "Interface IPersistentObject Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public interface IPersistentObject Methods Load(UnityReader) void Load(UnityReader reader) Parameters reader UnityReader Save(UnityWriter) void Save(UnityWriter writer) Parameters writer UnityWriter"
  },
  "api/SaveSystem.IPersistentObjectAsync.html": {
    "href": "api/SaveSystem.IPersistentObjectAsync.html",
    "title": "Interface IPersistentObjectAsync",
    "keywords": "Interface IPersistentObjectAsync Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public interface IPersistentObjectAsync Methods Load(UnityAsyncReader) UniTask Load(UnityAsyncReader asyncReader) Parameters asyncReader UnityAsyncReader Returns UniTask Save(UnityAsyncWriter) UniTask Save(UnityAsyncWriter asyncWriter) Parameters asyncWriter UnityAsyncWriter Returns UniTask"
  },
  "api/SaveSystem.MeshData.html": {
    "href": "api/SaveSystem.MeshData.html",
    "title": "Struct MeshData",
    "keywords": "Struct MeshData Contains the data of a mesh. Mesh can be casted to MeshData and vice-versa Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public struct MeshData Fields bounds public Bounds bounds Field Value Bounds colors32 public Color32[] colors32 Field Value Color32[] indexBufferTarget public GraphicsBuffer.Target indexBufferTarget Field Value GraphicsBuffer.Target indexFormat public IndexFormat indexFormat Field Value IndexFormat name public string name Field Value string normals public Vector3[] normals Field Value Vector3[] subMeshes public SubMeshDescriptor[] subMeshes Field Value SubMeshDescriptor[] subMeshIndices public int[][] subMeshIndices Field Value int[][] tangents public Vector4[] tangents Field Value Vector4[] triangles public int[] triangles Field Value int[] uv public Vector2[] uv Field Value Vector2[] uv2 public Vector2[] uv2 Field Value Vector2[] uv3 public Vector2[] uv3 Field Value Vector2[] uv4 public Vector2[] uv4 Field Value Vector2[] uv5 public Vector2[] uv5 Field Value Vector2[] uv6 public Vector2[] uv6 Field Value Vector2[] uv7 public Vector2[] uv7 Field Value Vector2[] uv8 public Vector2[] uv8 Field Value Vector2[] vertexBufferTarget public GraphicsBuffer.Target vertexBufferTarget Field Value GraphicsBuffer.Target vertices public Vector3[] vertices Field Value Vector3[] Operators implicit operator Mesh(MeshData) public static implicit operator Mesh(MeshData meshData) Parameters meshData MeshData Returns Mesh implicit operator MeshData(Mesh) public static implicit operator MeshData(Mesh mesh) Parameters mesh Mesh Returns MeshData"
  },
  "api/SaveSystem.UnityAsyncReader.html": {
    "href": "api/SaveSystem.UnityAsyncReader.html",
    "title": "Class UnityAsyncReader",
    "keywords": "Class UnityAsyncReader Adapter to class BinaryReader for simplify reading data async Inheritance object UnityAsyncReader Implements IDisposable Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public sealed class UnityAsyncReader : IDisposable Methods Dispose() public void Dispose() ReadBytes() public UniTask<byte[]> ReadBytes() Returns UniTask<byte[]> ReadColors() public UniTask<Color[]> ReadColors() Returns UniTask<Color[]> ReadColors32() public UniTask<Color32[]> ReadColors32() Returns UniTask<Color32[]> ReadFloatArray() public UniTask<float[]> ReadFloatArray() Returns UniTask<float[]> ReadIntArray() public UniTask<int[]> ReadIntArray() Returns UniTask<int[]> ReadMatrices() public UniTask<Matrix4x4[]> ReadMatrices() Returns UniTask<Matrix4x4[]> ReadMesh(int) public UniTask<MeshData> ReadMesh(int uvChannels = 1) Parameters uvChannels int Returns UniTask<MeshData> ReadObjects<T>() public UniTask<T[]> ReadObjects<T>() Returns UniTask<T[]> Type Parameters T ReadVector2Array() public UniTask<Vector2[]> ReadVector2Array() Returns UniTask<Vector2[]> ReadVector3Array() public UniTask<Vector3[]> ReadVector3Array() Returns UniTask<Vector3[]> ReadVector4Array() public UniTask<Vector4[]> ReadVector4Array() Returns UniTask<Vector4[]> ReadVersion() public Version ReadVersion() Returns Version"
  },
  "api/SaveSystem.UnityAsyncWriter.html": {
    "href": "api/SaveSystem.UnityAsyncWriter.html",
    "title": "Class UnityAsyncWriter",
    "keywords": "Class UnityAsyncWriter Adapter to class BinaryWriter for simplify writing data async Inheritance object UnityAsyncWriter Implements IDisposable IAsyncDisposable Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public sealed class UnityAsyncWriter : IDisposable, IAsyncDisposable Fields localPath public readonly string localPath Field Value string Methods Dispose() public void Dispose() DisposeAsync() public ValueTask DisposeAsync() Returns ValueTask Write(MeshData, int) public UniTask Write(MeshData meshData, int uvChannels = 1) Parameters meshData MeshData uvChannels int Returns UniTask Write(byte[]) public UniTask Write(byte[] bytes) Parameters bytes byte[] Returns UniTask Write(int[]) public UniTask Write(int[] intValues) Parameters intValues int[] Returns UniTask Write(float[]) public UniTask Write(float[] floatValues) Parameters floatValues float[] Returns UniTask Write(Version) public void Write(Version version) Parameters version Version Write(Color[]) public UniTask Write(Color[] colorsArray) Parameters colorsArray Color[] Returns UniTask Write(Color32[]) public UniTask Write(Color32[] colors32Array) Parameters colors32Array Color32[] Returns UniTask Write(Matrix4x4[]) public UniTask Write(Matrix4x4[] matrices) Parameters matrices Matrix4x4[] Returns UniTask Write(Vector2[]) public UniTask Write(Vector2[] vector2Array) Parameters vector2Array Vector2[] Returns UniTask Write(Vector3[]) public UniTask Write(Vector3[] vector3Array) Parameters vector3Array Vector3[] Returns UniTask Write(Vector4[]) public UniTask Write(Vector4[] vector4Array) Parameters vector4Array Vector4[] Returns UniTask Write<T>(T[]) public UniTask Write<T>(T[] objects) Parameters objects T[] Returns UniTask Type Parameters T"
  },
  "api/SaveSystem.UnityReader.html": {
    "href": "api/SaveSystem.UnityReader.html",
    "title": "Class UnityReader",
    "keywords": "Class UnityReader Adapter to class BinaryReader for simplify reading data Inheritance object UnityReader Implements IDisposable Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public sealed class UnityReader : IDisposable Methods Dispose() public void Dispose() ReadBool() public bool ReadBool() Returns bool ReadByte() public byte ReadByte() Returns byte ReadBytes() public byte[] ReadBytes() Returns byte[] ReadChar() public char ReadChar() Returns char ReadChars() public char[] ReadChars() Returns char[] ReadColor() public Color ReadColor() Returns Color ReadColor32() public Color32 ReadColor32() Returns Color32 ReadColors() public Color[] ReadColors() Returns Color[] ReadColors32() public Color32[] ReadColors32() Returns Color32[] ReadDouble() public double ReadDouble() Returns double ReadDoubles() public double[] ReadDoubles() Returns double[] ReadFloat() public float ReadFloat() Returns float ReadFloats() public float[] ReadFloats() Returns float[] ReadInt() public int ReadInt() Returns int ReadIntArray() public int[] ReadIntArray() Returns int[] ReadLong() public long ReadLong() Returns long ReadLongArray() public long[] ReadLongArray() Returns long[] ReadMatrices() public Matrix4x4[] ReadMatrices() Returns Matrix4x4[] ReadMatrix() public Matrix4x4 ReadMatrix() Returns Matrix4x4 ReadMesh() public MeshData ReadMesh() Returns MeshData ReadObject<T>() public T ReadObject<T>() Returns T Type Parameters T ReadObjectsArray<T>() public T[] ReadObjectsArray<T>() Returns T[] Type Parameters T ReadRotation() public Quaternion ReadRotation() Returns Quaternion ReadShort() public short ReadShort() Returns short ReadShorts() public short[] ReadShorts() Returns short[] ReadString() public string ReadString() Returns string ReadStringArray() public string[] ReadStringArray() Returns string[] ReadVector2() public Vector2 ReadVector2() Returns Vector2 ReadVector2Array() public Vector2[] ReadVector2Array() Returns Vector2[] ReadVector3() public Vector3 ReadVector3() Returns Vector3 ReadVector3Array() public Vector3[] ReadVector3Array() Returns Vector3[] ReadVector4() public Vector4 ReadVector4() Returns Vector4 ReadVector4Array() public Vector4[] ReadVector4Array() Returns Vector4[] ReadVersion() public Version ReadVersion() Returns Version"
  },
  "api/SaveSystem.UnityWriter.html": {
    "href": "api/SaveSystem.UnityWriter.html",
    "title": "Class UnityWriter",
    "keywords": "Class UnityWriter Adapter to class BinaryWriter for simplify writing data Inheritance object UnityWriter Implements IDisposable IAsyncDisposable Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public sealed class UnityWriter : IDisposable, IAsyncDisposable Fields localPath public readonly string localPath Field Value string Methods Dispose() public void Dispose() DisposeAsync() public ValueTask DisposeAsync() Returns ValueTask Write(MeshData) public void Write(MeshData mesh) Parameters mesh MeshData Write(bool) public void Write(bool boolValue) Parameters boolValue bool Write(byte) public void Write(byte byteValue) Parameters byteValue byte Write(byte[]) public void Write(byte[] bytes) Parameters bytes byte[] Write(char) public void Write(char charValue) Parameters charValue char Write(char[]) public void Write(char[] chars) Parameters chars char[] Write(double) public void Write(double doubleValue) Parameters doubleValue double Write(double[]) public void Write(double[] doubles) Parameters doubles double[] Write(short) public void Write(short shortValue) Parameters shortValue short Write(short[]) public void Write(short[] shorts) Parameters shorts short[] Write(int) public void Write(int intValue) Parameters intValue int Write(int[]) public void Write(int[] ints) Parameters ints int[] Write(long) public void Write(long longValue) Parameters longValue long Write(long[]) public void Write(long[] longs) Parameters longs long[] Write(float) public void Write(float floatValue) Parameters floatValue float Write(float[]) public void Write(float[] floats) Parameters floats float[] Write(string) public void Write(string stringValue) Parameters stringValue string Write(string[]) public void Write(string[] strings) Parameters strings string[] Write(Version) public void Write(Version version) Parameters version Version Write(Color) public void Write(Color color) Parameters color Color Write(Color[]) public void Write(Color[] colors) Parameters colors Color[] Write(Color32) public void Write(Color32 color32) Parameters color32 Color32 Write(Color32[]) public void Write(Color32[] colors32) Parameters colors32 Color32[] Write(Matrix4x4) public void Write(Matrix4x4 matrix) Parameters matrix Matrix4x4 Write(Matrix4x4[]) public void Write(Matrix4x4[] matrices) Parameters matrices Matrix4x4[] Write(Quaternion) public void Write(Quaternion rotation) Parameters rotation Quaternion Write(Vector2) public void Write(Vector2 vector2) Parameters vector2 Vector2 Write(Vector2[]) public void Write(Vector2[] vector2Array) Parameters vector2Array Vector2[] Write(Vector3) public void Write(Vector3 vector3) Parameters vector3 Vector3 Write(Vector3[]) public void Write(Vector3[] vector3Array) Parameters vector3Array Vector3[] Write(Vector4) public void Write(Vector4 vector4) Parameters vector4 Vector4 Write(Vector4[]) public void Write(Vector4[] vector4Array) Parameters vector4Array Vector4[] Write<T>(T) public void Write<T>(T obj) Parameters obj T Type Parameters T Write<T>(T[]) public void Write<T>(T[] arrayObjects) Parameters arrayObjects T[] Type Parameters T"
  },
  "changelog/CHANGELOG.html": {
    "href": "changelog/CHANGELOG.html",
    "title": "Changelog",
    "keywords": "Changelog [1.4.0] - 2023-04-22 Added Added asynchronous data handling: Added a new interface - the IPersistentObjectAsync for asynchronous handling of data Added the UnityAsyncWriter and UnityAsyncReader handlers - asynchronous handlers of data Expanded the DataManager - added simple and advanced asynchronous methods to save and load objects Changed Removed write and read meshes array methods Removed methods for writing and reading a list of objects. Instead, use the write and read methods of an array of objects. Removed methods for saving and loading a list of objects from the DataManager. Instead, use the save and load methods of an array of objects. [1.3.0] - 2023-04-17 Added Added write and read mesh and meshes array methods Added methods for writing and reading arrays of basic data types and unity structures Changed Removed methods for writing and reading MonoBehaviour classes. Use SaveObject method instead and implement the IPersistentObject interface in your MonoBehaviour classes [1.2.0] - 2023-04-15 Added Added methods for writing and reading unity structures such as Color32, Matrix4X4, Vector2, Vector4. Added methods for writing and reading classes which inherits from MonoBehaviour Changed Renamed \"ReadPosition\" method to \"ReadVector3\" (in UnityReader class) Fixed Fixed problem with writing data to file. UnityWriter was leaving \"trash\" bytes at the end of the file if it wrote fewer bytes than the file contains [1.1.1] - 2023-04-14 Added Added displaying of size of data (in \"Data Manager / Get Data Size\" menu in editor) [1.1.0] - 2023-04-14 Added Added support of saving single object and list of objects [1.0.0] - 2023-04-13 Added Create package"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the documentation of the Save System",
    "keywords": "Welcome to the documentation of the Save System See manual for quick start See Scripting API to more details of system usage See Cnangelog to know latest changes in the system"
  },
  "license/LICENSE.html": {
    "href": "license/LICENSE.html",
    "title": "",
    "keywords": "MIT License Copyright (c) 2023 Denis Dmitriev Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "manual/advanced.html": {
    "href": "manual/advanced.html",
    "title": "Advanced data handling",
    "keywords": "Advanced data handling In 99% cases you won't need to this, but you can write and read data asynchronously by using UnityAsyncWriter and UnityAsyncReader. In past examples only objects was saved asynchronously, but inside them data was written sync public void Save (UnityWriter writer) { writer.Write(myData); } Instead, you can write down data async in the same way as saving objects public async UniTask Save (UnityAsyncWriter asyncWriter) { await asyncWriter.Write(myData); } To do this, class of object must be implement the IPersistentObjectAsync interface instead of the IPersistentObject public class MyObject : IPersistentObjectAsync { public async UniTask Save (UnityAsyncWriter asyncWriter) { } public async UniTask Load (UnityAsyncReader asyncReader) { } } To save the object, you can pass it to DataManager.SaveObjectAsyncAdvanced method await DataManager.SaveObjectAsyncAdvanced(fileName, myObject); Notice that you don't pass AsyncMode to either SaveObjectAsyncAdvanced method, or the data handlers, because the data handlers handle data the same in both modes, so only one mode was chosen which support in every platforms. Separately about the mesh If you're generating a mesh with more than one uv channel and want to write down the generated mesh, you must pass the number of channels to the asyncWriter.Write method await asyncWriter.Write(generatedMeshData, uvChannels: 2); Similarly with reading generatedMeshData = await asyncReader.ReadMesh(uvChannels: 2); By default, asynchronous data handlers write and read one uv channel When I need to this You can use this when your objects have big arrays of data. In this case, you can split the job of writing and reading data. The every array will be read/write in a separate frame"
  },
  "manual/advice.html": {
    "href": "manual/advice.html",
    "title": "Backward compatibility advice",
    "keywords": "Backward compatibility advice For backward compatibility of your data files, it is recommended define the data reading logic based on the data file version. For this, you will write a version of the file, then read its from the data file and at the end reading data depending on the file version You can do it into any class by using any data handler. You can use Version class from System namespace and bind the file version to an application version private readonly Version m_currentVersion = new Version(Application.version); Let's say you decided to add some data to persist and then read its. If you read the old file which doesn't contain this data, you will get the EndOfStreamException, because the UnityReader will try to read more bytes than the data file contains. The following code example shows how to read data depending on the file version private readonly Version m_oldVersion1 = new Version(\"1.0.0\"); private readonly Version m_oldVersion2 = new Versiom(\"1.1.0\"); private readonly Version m_currentVersion = new Version(Application.version); // 1.2.0 public void Save (UnityWriter writer) { writer.Write(m_currentVersion); // other actions } public void Load (UnityReader reader) { var readVersion = reader.ReadVersion(); if (readVersion >= m_oldVersion1) { // performing some actions depending on the file version } // other actions if (readVersion >= m_oldVersion2) { // performing some actions depending on the file version } // other actions if (readVersion == m_currentVersion) { // performing some actions depending on the file version } } This is where you store old versions of your file, read the version of the data file, compare it to old versions and current version and read other data based on the read file version. You can choose an other way for persist the old versions (ex. in StreamingAssets folder in json file, or in some other way). The main thing is that you was comparing the file version to the old versions and the current one"
  },
  "manual/async-management.html": {
    "href": "manual/async-management.html",
    "title": "Asynchronous management",
    "keywords": "Asynchronous management DataManager can also save and load objects asynchronously. For example, if you're generating a heavy mesh and want to write down it, you wouldn't want to do it at runtime, else your game will freeze. To do it you can persist MyGenerator by using SaveObjectAsync method. You can await it or continue public async void Saving () { await DataManager.SaveObjectAsync(fileName, myGenerator, AsyncMode.OnThreadPool); // some actions } // or public void Saving () { DataManager.SaveObjectAsync(fileName, myGenerator, AsyncMode.OnThreadPool); // some actions } And then in MyGenerator you can write the mesh public void Save (UnityWriter writer) { writer.Write(m_meshData); } Note Before write down the mesh, you must get MeshData struct inside an other method and save it as class field to pass it to writer.Write method. You just can cast Mesh to MeshData, ex. public class MyGenerator : IPersistentObject { private MeshData m_meshData; private Mesh m_generatedMesh; public void PreSave () { m_meshData = m_generatedMesh; } // other actions } For more information about AsyncMode, see the chapter async modes If you are saving a lot of objects, you can observe the progress by passing a object to the DataManager which implement the IProgress<float> interface var progress = new Progress(); // it implements the IProgress<float> interface await DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, progress ); Also you can cancel operation by passing the cancellation token source to the DataManager var source = new CancellationTokenSource(); DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, progress: null, source ); // some actions source.Cancel(); If you cancel the save, DataManager will delete the save file. Finally you can pass a lambda to the manager. The lambda will be called after the completion of the process DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, progress: null, source: null, () => Debug.Log(\"Objects saved\") ); When you load objects, you can await the result in the same way as when you load objects synchronously public async void Loading () { if (await DataManager.LoadObjectsAsync(fileName, myObjects, AsyncMode.OnThreadPool)) { // some actions } }"
  },
  "manual/async-modes.html": {
    "href": "manual/async-modes.html",
    "title": "Async modes",
    "keywords": "Async modes You can choose how to save and load objects - in the player loop or in the thread pool. For example, to save objects in the player loop you must pass AsyncMode.OnPlayerLoop mode to SaveObject method await DataManager.SaveObjectAsync(fileName, myObjects, AsyncMode.OnPlayerLoop); Async mode defines where the objects will be saved - in the main thread (in the player loop, single thread mode), or in a background (in the thread pool, multithreading mode). Tip Running in the thread pool will be faster than running in the player loop, other things being equal If you save one object in the player loop asynchronously, it will be equivalent to synchronous save (however, in this case onComplete action will be called in the next frame) How to choose async mode Usually you will write down and read data in the thread pool, especially if you are saving and loading a lot of objects. But if you can't use multithreading (ex. when you're creating a game for the WebGL platform), you need to select a saving/loading in the player loop. AsyncMode Threading mode OnPlayerLoop The main thread usage OnThreadPool A background thread usage"
  },
  "manual/in-editor.html": {
    "href": "manual/in-editor.html",
    "title": "In editor",
    "keywords": "In editor In the unity editor there is a button for remove data It is active only when there is the data. After you remove the data, the button will be disabled. Also Save System menu contains Get Data Size button. It writing size of your data files in debug console"
  },
  "manual/installing.html": {
    "href": "manual/installing.html",
    "title": "Installing",
    "keywords": "Installing Do these steps to install the package: Click on the green button \"Code\" Then click on copy button, in \"HTTPS\" tab In Unity open the Package Manager window (Window/Package Manager) Then click on plus sign and select \"Add package from git URL\" Insert copied link and click on \"Add\" After a while the package will be added to your project"
  },
  "manual/intro.html": {
    "href": "manual/intro.html",
    "title": "About Save System",
    "keywords": "About Save System The save system is a package for saving and loading game data. This system allows you to save the state of the game at a some moment (ex. before quitting) and restore it after entering. You can choose one of the following ways to commit the state of the game: Synchronous Asynchronous single threading mode (on the player loop) Asynchronous multithreading mode (on the thread pool) In low level you can control unity structures such as Vector2, Vector3, Vector4, Quaternion, Color, Color32, Matrix4X4, Mesh. Also you can write down and read base data types and custom classes and structures. Installing Read Installing Manual to install this package Using Save System See Using Save System to learn how to use this system"
  },
  "manual/objects-control.html": {
    "href": "manual/objects-control.html",
    "title": "Objects control",
    "keywords": "Objects control In addition to unity structures and base data types, you can write down and read custom classes and structures. writer.Write<MyClass>(myClass); myClass = reader.ReadObject<MyClass>(); To write down (not save) a custom class, it must be serializable [Serializable] public class MyClass { public int intValue; // it will be saved [SerializeField] private bool boolValue; // and this private int m_intValue; // but not this public bool BoolValue { get; set; } // and not this } By default, its will be written as json string. If you want to override this, you can define extensions. For example public static class SaveSystemExtensions { public static void WriteMyClass (this UnityWriter writer, MyClass myClass) { writer.Write(myClass.position); writer.Write(myClass.rotation); writer.Write(myClass.boolValue); writer.Write(myClass.intValue); } public static MyClass ReadMyClass (this UnityReader reader) { return new MyClass { position = reader.ReadVector3(), rotation = reader.ReadRotation(), boolValue = reader.ReadBool(), intValue = reader.ReadInt() }; } } After then you can write down the class and read its as binary writer.WriteMyClass(myClass); myClass = reader.ReadMyClass();"
  },
  "manual/saving-and-loading.html": {
    "href": "manual/saving-and-loading.html",
    "title": "Saving and loading objects",
    "keywords": "Saving and loading objects DataManager is the main class for data management. It contains several methods for loading and saving objects. If you want to keep a MonoBehaviour object, you can write var myObject = FindObjectOfType<MyObject>(); DataManager.SaveObject(fileName, myObject); // \"fileName\" is the name of the data file without // full path and its extension (ex. \"myDataFile\"). To load the object if (DataManager.LoadObject(fileName, myObject)) { // some actions } The LoadObject method returns true if it successfully loaded object. It returns false if a save file is missing. The class of object must implement the IPersistentObject interface and Save and Load methods. public class MyObject : MonoBehaviour, IPersistentObject { public void Save (UnityWriter writer) { } public void Load (UnityReader reader) { } } The DataManager can also save and load multiple objects as array"
  },
  "manual/using.html": {
    "href": "manual/using.html",
    "title": "Using Save System",
    "keywords": "Using Save System Saving and loading data consist of the following steps: Implement the IPersistentObject or IPersistentObjectAsync interface in your object Implement Save and Load methods in it: Write down data in the save method by using UnityWriter Read data in the load method by using UnityReader Pass the object to the DataManager: Pass it to SaveObject method for saving Or pass it to LoadObject to load See saving and loading data for more information about using of the DataManager Then see writing and reading data for more about of the UnityWriter and the UnityReader And at the end see more information about asynchronous data management in this manual"
  },
  "manual/writing-and-reading.html": {
    "href": "manual/writing-and-reading.html",
    "title": "Writing and reading data",
    "keywords": "Writing and reading data To write and read data, the save system provides two classes - UnityWriter and UnityReader. They can write and read data respectively. Your MonoBehaviour classes get these data handler from the DataManager when you're saving or loading them. To write and read data you would write public void Save (UnityWriter writer) { writer.Write(transform.position); writer.Write(transform.rotation); writer.Write(material.color); writer.Write(myClass); writer.Write(myClasses); } public void Load (UnityReader reader) { transform.position = reader.ReadVector3(); transform.rotation = reader.ReadRotation(); material.color = reader.ReadColor(); myClass = reader.ReadObject<MyClass>(); myClasses = reader.ReadArrayObjects<MyClass>(); } Important You must read data in the same order as you write it. To learn how to control custom classes and structs see this part"
  }
}